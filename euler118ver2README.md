# Euler Problem \#118 Solution

## Problem

[Project Euler Problem \#118](https://projecteuler.net/problem=118) asks one to determine the total number of unique freely partitioned/permuted sets that can be generated from the digits <img src="/tex/191f83655de7a2df8eeb6f6eb14f2a99.svg?invert_in_darkmode&sanitize=true" align=middle width=148.85836844999997pt height=24.65753399999998pt/> that contain only prime numbers. One example of such a freely partitioned/permuted set containing only prime numbers would be <img src="/tex/26eb9856f03d0d379d7b23365a109e59.svg?invert_in_darkmode&sanitize=true" align=middle width=119.63483564999999pt height=24.65753399999998pt/>.

## Solution

*For ease of explanation, we use a generalizable solution for a smaller case, the digits <img src="/tex/49ea04cec1cb80915d565f17c1b6dd55.svg?invert_in_darkmode&sanitize=true" align=middle width=71.23290569999999pt height=24.65753399999998pt/>.*

[Here is the code.](euler118ver2.py)

### Brief Overview

First, calculate and store the total number of primes which can be generated by choosing digits from <img src="/tex/49ea04cec1cb80915d565f17c1b6dd55.svg?invert_in_darkmode&sanitize=true" align=middle width=71.23290569999999pt height=24.65753399999998pt/>. Then, calculate the total number of ways of partitioning <img src="/tex/49ea04cec1cb80915d565f17c1b6dd55.svg?invert_in_darkmode&sanitize=true" align=middle width=71.23290569999999pt height=24.65753399999998pt/>. For each way of partitioning, look up the total number of primes as stored in step 1, and thereby count the total number of freely partitioned/permuted sets that only contain prime numbers.

### Somewhat-Less-Brief Overview

The solution will work in the following steps:

1. Recursively generate combinations to count all possible ways of choosing digits from <img src="/tex/49ea04cec1cb80915d565f17c1b6dd55.svg?invert_in_darkmode&sanitize=true" align=middle width=71.23290569999999pt height=24.65753399999998pt/>. One such choice would be <img src="/tex/d29209c34e77cafe37bcc3bfbbcfe444.svg?invert_in_darkmode&sanitize=true" align=middle width=40.18272059999999pt height=24.65753399999998pt/>.
2. Recursively generate permutations to count all possible ways of internally rearranging the combinations found in step 1. For example, <img src="/tex/d29209c34e77cafe37bcc3bfbbcfe444.svg?invert_in_darkmode&sanitize=true" align=middle width=40.18272059999999pt height=24.65753399999998pt/> can be permuted as either <img src="/tex/9cb3c0a68645bef07ea731f2c7f52c22.svg?invert_in_darkmode&sanitize=true" align=middle width=16.438418699999993pt height=21.18721440000001pt/> or <img src="/tex/079c33e81efa6dc71650ddf156fa5374.svg?invert_in_darkmode&sanitize=true" align=middle width=16.438418699999993pt height=21.18721440000001pt/>.
3. Use naive trial division to calculate which of the permutations from step 2 are prime. For example, <img src="/tex/9cb3c0a68645bef07ea731f2c7f52c22.svg?invert_in_darkmode&sanitize=true" align=middle width=16.438418699999993pt height=21.18721440000001pt/> is not prime, but <img src="/tex/079c33e81efa6dc71650ddf156fa5374.svg?invert_in_darkmode&sanitize=true" align=middle width=16.438418699999993pt height=21.18721440000001pt/> is.
4. Store the results from steps 1-3 in a dictionary-like object whose are keys all the combinations from step 1. Each combination-key's paired value is the number of prime permutations for that combination-key. So, this dictionary would contain the following key-value pair: <img src="/tex/62f2d0d4c3e0b98806639f07ef4198c5.svg?invert_in_darkmode&sanitize=true" align=middle width=38.35605014999999pt height=21.18721440000001pt/>.
5. Recursively list [the possible ways of partitioning](https://oeis.org/A000041) a set containing 4 objects. One such partition would be <img src="/tex/c6c488eda354775464fb56202166e986.svg?invert_in_darkmode&sanitize=true" align=middle width=32.87674994999999pt height=24.65753399999998pt/>.
6. For a particular partition, use recursion to count the different ways of slotting digits (partition choices) into each slice of the partition. For <img src="/tex/c6c488eda354775464fb56202166e986.svg?invert_in_darkmode&sanitize=true" align=middle width=32.87674994999999pt height=24.65753399999998pt/>, <img src="/tex/99a707c587e82c2618919f04d0d03bb4.svg?invert_in_darkmode&sanitize=true" align=middle width=56.62113929999999pt height=24.65753399999998pt/> and <img src="/tex/7a77c21a39a7b2bb5bc0b5d338b9855d.svg?invert_in_darkmode&sanitize=true" align=middle width=56.62113929999999pt height=24.65753399999998pt/> would be two such partition choices.
7. For each element within a partition choice, look up the corresponding value in the dictionary from step 4. Multiply these values together to determine the number of exclusively-prime freely-permuted sets that each partition choice produces.
8. Iterate through the possible partitions of <img src="/tex/49ea04cec1cb80915d565f17c1b6dd55.svg?invert_in_darkmode&sanitize=true" align=middle width=71.23290569999999pt height=24.65753399999998pt/>, repeating steps 6 and 7 for each, and sum the results.

### Solution Advantages

* Adheres to black-box paradigm
* Generalizable for different-size inputs
* Saves time by not separately calculating possibilities such as <img src="/tex/6e6028c91be0af54e35b4daa39132705.svg?invert_in_darkmode&sanitize=true" align=middle width=63.927022499999985pt height=24.65753399999998pt/> and <img src="/tex/3bcfac7c7bd563fa602f66d544b86fd5.svg?invert_in_darkmode&sanitize=true" align=middle width=63.927022499999985pt height=24.65753399999998pt/> but just keeps tracking of how many permutations of <img src="/tex/d29209c34e77cafe37bcc3bfbbcfe444.svg?invert_in_darkmode&sanitize=true" align=middle width=40.18272059999999pt height=24.65753399999998pt/> are prime. (Note that for the larger input <img src="/tex/191f83655de7a2df8eeb6f6eb14f2a99.svg?invert_in_darkmode&sanitize=true" align=middle width=148.85836844999997pt height=24.65753399999998pt/> there are many possible partition choices which contain <img src="/tex/9cb3c0a68645bef07ea731f2c7f52c22.svg?invert_in_darkmode&sanitize=true" align=middle width=16.438418699999993pt height=21.18721440000001pt/>).
* Only runs trial division once per-permutation, instead of multiple times for every free concatenation that contains an identical element

### Solution Disadvantages

* Over 100 lines of code
* Uses primarily brute force leading to poor runtime scalability (although is acceptable speed for the given inputs)
* Computes possible combinations multiple times throughout algorithm
* Uses naive trial division instead of faster prime-checking algorithm

### Time Complexity

Let <img src="/tex/55a049b8f161ae7cfeb0197d75aff967.svg?invert_in_darkmode&sanitize=true" align=middle width=9.86687624999999pt height=14.15524440000002pt/> be the number of input digits. To generate the dictionary-object (by far the most computationally expensive part of the algorithm), we iterate the following for <img src="/tex/63bb9849783d01d91403bc9a5fea12a2.svg?invert_in_darkmode&sanitize=true" align=middle width=9.075367949999992pt height=22.831056599999986pt/>, <img src="/tex/2e0718b4fc1ff2133bc1efb704f46a7d.svg?invert_in_darkmode&sanitize=true" align=middle width=70.99670984999999pt height=22.831056599999986pt/>:

1. Calculate the number of permutations which can be made with <img src="/tex/63bb9849783d01d91403bc9a5fea12a2.svg?invert_in_darkmode&sanitize=true" align=middle width=9.075367949999992pt height=22.831056599999986pt/> elements from <img src="/tex/55a049b8f161ae7cfeb0197d75aff967.svg?invert_in_darkmode&sanitize=true" align=middle width=9.86687624999999pt height=14.15524440000002pt/>, having <img src="/tex/7e8803eeded8d24140bb3f159a2fa39c.svg?invert_in_darkmode&sanitize=true" align=middle width=48.975455099999984pt height=27.94539330000001pt/> complexity.
2. Calculate trial division on each permutation. Since a permutation <img src="/tex/2ec6e630f199f589a2402fdf3e0289d5.svg?invert_in_darkmode&sanitize=true" align=middle width=8.270567249999992pt height=14.15524440000002pt/> with <img src="/tex/63bb9849783d01d91403bc9a5fea12a2.svg?invert_in_darkmode&sanitize=true" align=middle width=9.075367949999992pt height=22.831056599999986pt/> digits must have that <img src="/tex/3e591bb5bde264b569c219b04c4fb9b9.svg?invert_in_darkmode&sanitize=true" align=middle width=53.89264649999999pt height=27.91243950000002pt/>, trial division runs in <img src="/tex/aea3a2d1b6dea2f0a1568ec4cb4269ad.svg?invert_in_darkmode&sanitize=true" align=middle width=49.34640644999999pt height=24.995338500000003pt/> time, and <img src="/tex/3e9d220323484afde06c862d25d25c3e.svg?invert_in_darkmode&sanitize=true" align=middle width=40.85986904999999pt height=22.831056599999986pt/>, trial division of each permutation has worst-case runtime <img src="/tex/0dc1414c5d3ad17528bd5b861a9bcd76.svg?invert_in_darkmode&sanitize=true" align=middle width=141.00933329999998pt height=28.511366399999982pt/>.

This results in a runtime which is expressed with the following series:

<p align="center"><img src="/tex/dfc8e69c31c14665015ae79774b2c0f0.svg?invert_in_darkmode&sanitize=true" align=middle width=442.33883265pt height=45.2741091pt/></p>

For which a simple worst-case upper bound is:

<p align="center"><img src="/tex/182040cc4fdb9fc2b8c4557cb3345b9d.svg?invert_in_darkmode&sanitize=true" align=middle width=233.4444486pt height=19.16777445pt/></p>

## Results

For the case given in the problem, this code produces the correct answer that there are <img src="/tex/f0e50717eacb7e1b1d81c5b7b220d3bd.svg?invert_in_darkmode&sanitize=true" align=middle width=48.401929949999996pt height=21.18721440000001pt/> unique freely partitioned/permuted sets that can be generated. On my machine, it does so in about 40 seconds.
